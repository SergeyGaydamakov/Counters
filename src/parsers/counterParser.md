Требуется на основании файла counters.csv (разделение точка с запятой, в кавычках точка с запятой экранируется) создать файл countersCfg.json, который по структуре аналогичен @countersConfig.json и содержит массив объектов следующей структуры:
  {
    "name": "counter_total",	// Название счетчика
    "comment": "counter_total - подсчет количества", // Комментарий для дополнительной информации или описания
    "indexTypeName": "idx_f1", // Название индекса, относительно которого вычисляется счетчик
    "computationConditions": {	// Условия импользования счетчика в вычисления, операторы запросов MongoDB
      "t": {"$in": [ 1, 2]},
	  "d.f1": "value1",
	  "d.f2": { "$regex": "pattern", "$options": "si" }
    },
    "evaluationConditions": {	// Условие подставляемое в aggregation pipline MongoDB запроса для вычисления счетчика на этапе $match в конструкции $facet
		"d.a": {
			"$gte": 1000
		},
		"d.f2": {
			"$nin": [
			  "value2",
			  "value4",
			  "value6",
			  "value8",
			  "value10"
			]
		},
		{"$expr": {"$eq": ["d.f1", "d.f2"]}}
	},
    "attributes": {			// Вычисляемые поля на этапе $group в конструкции $facet
      "cnt": {				// Число элементов 
        "$sum": 1
      },
      "sum": {
        "$sum": "$d.a"
      },
      "max": {
        "$max": "$d.a"
      },
      "avg": {
        "$avg": "$d.a"
      },
      "dst": {
        "$addToSet": "$t"
      }
    }
  }

Столбец "Name" - название счетчика для атрибута name
Столбец "Comment" - комментарий для атрибута comment
Столбец "Evaluation Conditions" - условие для атрибута evaluationConditions, данное условия в файле counters.txt находится в кавычках.
Столбец "Computation Conditions" - условие для атрибута computationConditions, данное условия в файле counters.txt находится в кавычках.
Столбец "Index" - название индекса для атрибута indexTypeName
Столбец Attributes содержит перечисление агрегатов счетчика, которые соответствуют следующим аккумуляторам MongoDB:
- average amount - средняя сумма, название агрегата avg, используется аккумулятор $avg
- distinct values number - количество уникальных значений, название агрегата dst, используется аккумулятор $addToSet
- frequency - частота, название агрегата dst, используется аккумулятор $sum: 1
- maximum amount - максимальная сумма, название агрегата max, используется аккумулятор $max
- minimum amount - минимальная сумма, название агрегата min, используется аккумулятор $min
- total amount - общая сумма, название агрегата sum, используется аккумулятор $sum
 
"Evaluation Conditions" и "Computation Conditions" содержат описание условий, которые объединяют набор выражений по AND.
В скобках описывается одно выражение, например (MessageTypeID = 61; 50);
Это выражение содержит имя поля в данных факта (MessageTypeID), оператор (=) и одно или несколько строковых значений (61; 50).
Данное выражение нужно преобразовать в выражение для MongoDB. Для данного примера это будет:
"d.MessageTypeID": {"$in": ["61","50"]}
Другие операторы выражений:
fieldName =*= value1, value2 - поле fieldName содержит подстроку value1 или value2
fieldName ¬=*= value1, value2 - поле fieldName не содержит подстроки value1 и value2
fieldName *= value1, value2 - поле fieldName начинается с подстроки value1 или value2
fieldName ¬*= value1, value2 - поле fieldName не начинается с подстрок value1 и value2
fieldName = value1 -  поле fieldName равно значению value1
fieldName = value1, value2 -  поле fieldName равно одному из значений value1 или value2
fieldName ≠ value1 -  поле fieldName не равно значению value1
fieldName ≠ value1, value2 -  поле fieldName не равно ни одному из значений value1 или value2
fieldName is true/false - поле fieldName имеет значение true или false.
Символ ∅ означает null или отсутствующее значение или отсутствующее поле
Если будет обнаружен неизвестный оператор, то игнорируй данное выражение и отделно добавляй в комментарий убранное исходное выражение.
Если в "Computation Conditions" в правой части выражения указано значение в фигурных скобках, например {fieldNameValue}, или значение квадратных скобках, например [fieldNameValue], то это означает, что нужно на этом месте вывести "d.fieldNameValue". Например, если выражение "(s_client_id ≠ [p_dstClientId]);", то на выходе должно быть "d.s_client_id": {"$ne": "d.p_dstClientId"}.
Если в "Evaluation Conditions" в правой части выражения указано значение в фигурных скобках, например {fieldNameValue}, то это означает, что нужно на этом месте вывести "$$d.fieldNameValue". Например, если выражение "(p_prv_grp_id = {p_prv_grp_id});", то на выходе должно быть "d.p_prv_grp_id": "$$d.p_prv_grp_id".
Если в "Evaluation Conditions" в правой части выражения указано значение квадратных скобках, например [fieldNameValue], то это означает, что нужно такое выражение написать через "$expr" и в правой части указать название поля "d.fieldNameValue". Например, для выражения "(s_client_id ≠ [s_client_id_dst]);" должно получиться {"$expr": {"$eq": ["$s_client_id", "$s_client_id_dst"]}}.
Если в выражении есть сравнение с датами и временем, то нужно использовать фунции даты и времени относительно текущего момента. Например, для выражения (Timestamp < ([md_INN_recepient_reg_dt] + 730d)) должно получится "Timestamp": {"$lt": {$dateadd: {startDate: "$md_INN_recepient_reg_dt", "unit": "day", amount: 720}}}.
Все значения value должны быть строками, даже если указано число, за исключением ситуаций, когда используются операции сравнения больше/меньше или для поля MessageTypeID, которое значения которого целые числа.
В computationConditions равенство на скалярное значение нужно указывать в сокращенной форме "fieldName": value1, без использования операторов.
В computationConditions равенство на равенство одному из значений массива нужно указывать в сокращенной форме "fieldName": ["value1", "value2"], без использования операторов.
После разработки парсера файла counters.txt сохрани рабочую версию, не удаляй парсер.

**Типизация значений:**
- MessageTypeID: всегда числа (int)
- Операции сравнения (>, <, >=, <=): числа для числовых полей, строки для текстовых
- Операции равенства (=, ≠): строки по умолчанию, числа для MessageTypeID
- Операции с подстроками (=*=, *=): строки
- Логические поля (is true/false): boolean
- Поля с суффиксом _flag, _indicator: boolean

**Обработка дат и времени:**
- Паттерн: `(fieldName < ([otherField] + 730d))` → `{"fieldName": {"$lt": {"$dateAdd": {"startDate": "$otherField", "unit": "day", "amount": 730}}}}`
- Поддерживаемые единицы: d (дни), h (часы), m (минуты), s (секунды)
- Функции: $dateAdd, $dateSubtract, $now для текущего времени
- Примеры полей с датами: Timestamp, reg_dt, created_at, updated_at

**Обработка ошибок:**
- Неизвестные операторы → логирование в комментарий + пропуск выражения
- Некорректные значения → валидация и исправление где возможно
- Дублирующиеся условия → объединение через $and
- Пустые обязательные поля → ошибка с указанием строки

**Валидация результата:**
- Проверка корректности MongoDB операторов
- Валидация структуры JSON
- Проверка ссылок на индексы (indexTypeName)

**Расширенные примеры:**

1. Сложные условия:
   Вход: `"(MessageTypeID = 61; 50); (msgMode = CI); (rules =*= atm88.1)"`
   Выход: 
	```json
   {
     "d.MessageTypeID": {"$in": [61, 50]},
     "d.msgMode": "CI",
     "d.rules": {"$regex": "atm88.1", "$options": "i"}
   }
	```

